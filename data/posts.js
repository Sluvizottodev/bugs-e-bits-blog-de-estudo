export const posts = [
    {
        id: 1,
        titulo: "Introdu√ß√£o ao React: Fundamentos e Primeiros Passos",
        resumo: "Uma introdu√ß√£o pr√°tica ao React: JSX, componentes, estado e como montar sua primeira aplica√ß√£o passo a passo.",
        conteudo: `React mudou a forma como pensamos interfaces. Neste post eu guio voc√™ pelos conceitos essenciais para come√ßar com confian√ßa: o que √© JSX, a diferen√ßa entre componentes de fun√ß√£o e de classe, como funciona o fluxo de dados com props e state, e por que o conceito de "composi√ß√£o" √© t√£o poderoso.

Come√ßamos montando uma pequena aplica√ß√£o Todo: criar componentes simples, passar dados por props e manipular estado local. Em seguida explico hooks fundamentais (useState, useEffect) e mostro situa√ß√µes pr√°ticas para cada um. Tamb√©m comento boas pr√°ticas de estrutura de pastas, reutiliza√ß√£o de componentes e como pensar testabilidade desde o in√≠cio.

Dicas r√°pidas de produtividade: use devtools do React, divida a UI em componentes pequenos, escreva testes unit√°rios para l√≥gica importante e adote lint/formatters para manter o c√≥digo consistente. No final proponho exerc√≠cios: criar um formul√°rio controlado, consumir uma API p√∫blica e levantar estados de loading/erro.

Se voc√™ est√° come√ßando, foque em entender o pensamento reativo e praticar muito pequenos componentes. Se j√° tem familiaridade, experimente hooks customizados e patterns de composi√ß√£o para elevar seu c√≥digo.`,
        dataCriacao: "2024-03-15T10:30:00",
        categoria: "frontend",
        tags: ["react", "javascript", "frontend"],
        destaque: true,
        tempoLeitura: "7 min",
        imagem: "assets/images/react-intro.jpg"
    },
    {
        "id": 3,
        "titulo": "Modelos de Software: Do Cascata ao √Ågil, Qual Usar?",
        "resumo": "Um guia pelos principais modelos de processo de software: Cascata, Prototipa√ß√£o, Espiral, RUP e √Ågil. Explica√ß√µes pr√°ticas, compara√ß√µes e dicas para escolher o melhor para seu projeto.",
        "conteudo": `Se voc√™ j√° se perguntou como os times de desenvolvimento organizam seu trabalho para construir software, a resposta est√° nos modelos de processo. Eles s√£o como receitas de bolo: cada um tem seu jeito de misturar os ingredientes (requisitos, c√≥digo, testes) e assar (entregar) o produto final. Vamos mergulhar nos principais!

# 1. üíß Modelo Cascata (Waterfall)
O cl√°ssico! √â linear e sequencial: primeiro definimos todos os requisitos, depois fazemos o design, a√≠ codificamos, testamos e s√≥ ent√£o entregamos. N√£o volta atr√°s.
- Como funciona: Parece uma escada: voc√™ s√≥ sobe um degrau depois de terminar o anterior.
- Exemplo pr√°tico: Construir um pr√©dio. Voc√™ n√£o come√ßa a levantar as paredes sem ter a planta aprovada.
- Melhor para: Projetos com requisitos muito claros e que n√£o mudam (ex.: sistema de contabilidade).
- Desvantagem: Se o cliente mudar de ideia no meio, o retrabalho √© enorme e caro.

# 2. üé® Prototipa√ß√£o
Aqui, a ideia √© criar um rascunho r√°pido (prot√≥tipo) do software para validar ideias com o cliente e ajustar os requisitos antes de desenvolver de verdade.
- Como funciona: Ciclos r√°pidos de feedback. Mostra-se uma vers√£o simples, o cliente d√° palpite, e voc√™ refina.
- Exemplo pr√°tico: Desenhar a interface de um app num papel ou ferramenta de design e mostrar para o usu√°rio antes de codificar.
- Melhor para: Quando ningu√©m sabe exatamente como o sistema deve ficar.
- Cuidado: O cliente pode achar que o prot√≥tipo √© a vers√£o final e se frustrar.

# 3. üîÑ Modelo Espiral
Imagine um caracol: cada volta √© um ciclo que passa por quatro quadrantes: planejamento, an√°lise de risco, desenvolvimento e avalia√ß√£o. √â iterativo e focado em gerenciar riscos.
- Como funciona: A cada volta, voc√™ entrega uma vers√£o mais completa do software, sempre avaliando os riscos (t√©cnicos, de prazo, de custo).
- Exemplo pr√°tico: Desenvolver um carro el√©trico aut√¥nomo. Come√ßa com um modelo b√°sico que anda sozinho em estrada reta (ciclo 1), depois adiciona detec√ß√£o de obst√°culos (ciclo 2), depois navega√ß√£o urbana (ciclo 3), e assim por diante.
- Melhor para: Projetos grandes, complexos e de alto risco (ex.: software aeroespacial).
- Desvantagem: √â complexo de gerenciar e exige muita experi√™ncia.

# 4. üß© RUP (Rational Unified Process)
√â um processo iterativo tamb√©m, mas bem estruturado. Divide o projeto em fases (Concep√ß√£o, Elabora√ß√£o, Constru√ß√£o, Transi√ß√£o) e em disciplinas (Requisitos, Projeto, etc.). √â como ter um mapa detalhado para uma viagem.
- Como funciona: Dirigido por casos de uso e focado na arquitetura. A cada itera√ß√£o, voc√™ passa por v√°rias disciplinas.
- Exemplo pr√°tico: Desenvolver um sistema ERP para uma grande empresa. Voc√™ precisa de uma arquitetura robusta desde o in√≠cio.
- Melhor para: Projetos grandes que precisam de alta qualidade e documenta√ß√£o.
- Desvantagem: Pode ser considerado burocr√°tico e pesado para projetos pequenos.

# 5. ‚ö° √Ågil (e Scrum) - O Foco
Eis a estrela do s√©culo XXI! O Manifesto √Ågil valoriza:
- Indiv√≠duos e intera√ß√µes sobre processos e ferramentas.
- Software em funcionamento sobre documenta√ß√£o abrangente.
- Colabora√ß√£o com o cliente sobre negocia√ß√£o de contratos.
- Responder a mudan√ßas sobre seguir um plano.

Dentro do √Ågil, o *Scrum* √© o framework mais popular. Ele divide o trabalho em *Sprints* (itera√ß√µes de 2-4 semanas). No in√≠cio de cada Sprint, o time escolhe itens do *Product Backlog* (lista de tarefas priorizada) para executar. Todo dia, uma reuni√£o r√°pida de 15min (*Daily Scrum*) para sincronizar. No final da Sprint, entrega-se uma vers√£o funcional do software e faz-se uma retrospectiva para melhorar.

- Como funciona: Time pequeno e auto-gerenci√°vel, com Pap√©is claros (Product Owner, Scrum Master, Dev Team), Artefatos (Backlog, Sprint) e Cerim√¥nias (Planning, Daily, Review, Retro).
- Exemplo pr√°tico: Desenvolver um app de delivery. A cada Sprint, entrega-se uma funcionalidade nova: cadastro de usu√°rios, card√°pio online, carrinho de compras, etc.
- Melhor para: Projetos com requisitos vol√°teis, que precisam de entrega r√°pida e adapta√ß√£o (ex.: startups, produtos inovadores).
- Desvantagem: Pode virar uma "correria" se n√£o for bem facilitado (Scrum Master faz falta!).

## Como Escolher?
- Cascata: Requisitos est√°veis e bem entendidos.
- Prototipa√ß√£o: Requisitos incertos e necessidade de valida√ß√£o r√°pida.
- Espiral: Projetos cr√≠ticos e cheios de riscos.
- RUP: Projetos grandes com necessidade de arquitetura s√≥lida e documenta√ß√£o.
- √Ågil/Scrum: Ambientes din√¢micos, com necessidade de velocidade e flexibilidade.

E a√≠, qual modelo combina mais com seu projeto? A chave √© adaptar e misturar ideias √†s vezes! O importante √© entregar valor de forma consistente. üöÄ`,
        "dataCriacao": "2025-09-18T12:00:00",
        "categoria": "software",
        tags: ["modelos", "√°gil", "scrum", "processo", "desenvolvimento"],
        "destaque": true,
        "tempoLeitura": "12 min",
        "imagem": "https://www.levty.com/blog/assets/post/diferencas-entre-metodologias-6581a07ae8bea1272c256c57/scrum-levty.webp"
    },
    {
        id: 4,
        titulo: "Carreira em TI: Como se Tornar um Desenvolvedor Full-Stack",
        resumo: "Um guia realista para planejar a carreira full-stack: habilidades t√©cnicas, soft skills, portf√≥lio e como buscar oportunidades.",
        conteudo: `A jornada para ser full-stack combina curiosidade t√©cnica com h√°bitos de aprendizado constantes. Aqui organizo um roteiro pr√°tico: fundamentos (l√≥gica, algoritmos, banco de dados), front-end (HTML, CSS, JS, frameworks) e back-end (linguagens, APIs, banco de dados). Mas a diferen√ßa est√° nas soft skills: comunica√ß√£o, trabalho em equipe, revis√£o de c√≥digo e responsabilidade com qualidade.

Exploro tamb√©m como montar um portf√≥lio relevante: projetos pequenos e bem documentados, foco nas entregas e em explicar decis√µes t√©cnicas. Dicas para entrevistas t√©cnicas, resolu√ß√£o de problemas ao vivo, e como transformar feedback em evolu√ß√£o. Menciono caminhos alternativos: especializa√ß√£o em backend, mobile ou devops, dependendo do seu gosto.

Por fim, falo sobre redes de suporte: comunidades, mentoria e cursos pr√°ticos. A sugest√£o final √© simples: escolha um projeto que resolva um problema real e entregue-o do in√≠cio ao fim ‚Äî isso ensina mais do que qualquer checklist te√≥rico.`,
        dataCriacao: "2024-03-01T16:45:00",
        categoria: "career",
        tags: ["carreira", "fullstack", "ti"],
        destaque: true,
        tempoLeitura: "12 min",
        imagem: "assets/images/career-path.jpg"
    },
    {
        id: 5,
        titulo: "CSS Grid vs Flexbox: Quando Usar Cada Um",
        resumo: "Compara√ß√£o pr√°tica entre Grid e Flexbox com exemplos de layout responsivo e padr√µes de uso recomendados.",
        conteudo: `Grid e Flexbox s√£o ferramentas complementares, n√£o rivais. Flexbox resolve muito bem layouts em linha ou coluna (componentes, barras, cards), enquanto Grid brilha em layouts bidimensionais (grades complexas, √°reas definidas). Aqui eu trago casos de uso claros: quando usar Flexbox para alinhar itens em uma barra de navega√ß√£o; quando usar Grid para montar um layout de p√°gina com header, sidebar e conte√∫do principal.

Incluo exemplos pr√°ticos de c√≥digo, t√©cnicas para responsividade (media queries, fr/auto/minmax) e como combinar os dois para obter flexibilidade m√°xima. Tamb√©m discuto acessibilidade visual e ordem visual vs ordem DOM ‚Äî importante para leitores de tela e SEO.

Conselho de estilo: prefira solu√ß√µes simples, com componentes reutiliz√°veis, e teste em diversas resolu√ß√µes. Como exerc√≠cio, reconstruir um layout complexo usando Grid e depois refatorar partes com Flexbox para entender trade-offs.`,
        dataCriacao: "2024-02-28T11:20:00",
        categoria: "frontend",
        tags: ["css", "grid", "flexbox"],
        destaque: false,
        tempoLeitura: "9 min",
        imagem: "assets/images/css-grid-flexbox.jpg"
    },
    {
        id: 6,
        titulo: "Node.js: Construindo APIs Escal√°veis e Confi√°veis",
        resumo: "Princ√≠pios para projetar APIs eficientes com Node.js e Express, incluindo arquitetura, testes, seguran√ßa e deployment.",
        conteudo: `Node.js traz um modelo de I/O n√£o bloqueante ideal para APIs de alta concorr√™ncia. Neste texto exploro arquitetura de servi√ßos: separa√ß√£o de responsabilidades, uso de middleware no Express, e padr√µes para tratamento de erros e logs. Falo sobre gerenciamento de processos (PM2, clustering), estrat√©gias de cache e otimiza√ß√£o de consultas ao banco.

Incluo pr√°ticas essenciais de seguran√ßa: valida√ß√£o de entrada, prote√ß√£o contra injection, rate limiting e headers seguros. Abordo testes unit√°rios e de integra√ß√£o (Jest, Supertest) e pipelines de CI/CD que automatizam build, testes e deploy.

Finalizo com op√ß√µes de deploy: containers Docker, orquestra√ß√£o b√°sica e observability m√≠nima (health checks, metrics). Como proposta pr√°tica: construir uma API com autentica√ß√£o JWT, testes automatizados e deploy em container para entender o fluxo completo.`,
        dataCriacao: "2024-02-25T13:10:00",
        categoria: "backend",
        tags: ["nodejs", "express", "javascript"],
        destaque: false,
        tempoLeitura: "11 min",
        imagem: "assets/images/nodejs-api.jpg"
    },
    {
        id: 7,
        titulo: "Flutter: Desenvolvimento Cross-Platform na Pr√°tica",
        resumo: "Como pensar em widgets, estado e navega√ß√£o no Flutter para criar apps nativos para iOS e Android com qualidade.",
        conteudo: `Flutter √© poderoso porque unifica UI e l√≥gica com widgets. Neste post detalho o ciclo de vida de widgets, a diferen√ßa entre Stateless e Stateful, e mostro como estruturar um app escal√°vel: separa√ß√£o entre apresenta√ß√£o, estado e servi√ßos. Apresento estrat√©gias de gerenciamento de estado (Provider, Riverpod, Bloc) e quando escolher cada uma dependendo da complexidade do projeto.

Falo sobre navega√ß√£o, rotas nomeadas, anima√ß√µes simples e integra√ß√£o com recursos nativos (c√¢mera, sensores, plugins). Tamb√©m discuto performance: evitar rebuilds desnecess√°rios, usar const widgets, e profiling com o DevTools do Flutter. Cobro tamb√©m testes: widget tests e integration tests para garantir que as partes cr√≠ticas do app funcionem em diferentes dispositivos.

No final proponho um mini-projeto: construir um app de lista com persist√™ncia local, consumo de API e testes autom√°ticos. √â uma forma pr√°tica de colocar em jogo conceitos de arquitetura e qualidade.`,
        dataCriacao: "2024-03-05T09:15:00",
        categoria: "mobile",
        tags: ["flutter", "dart", "mobile"],
        destaque: false,
        tempoLeitura: "8 min",
        imagem: "assets/images/flutter-app.jpg"
    }

];

export function getPostsByCategory(category) {
    if (category === 'all') return posts;
    return posts.filter(post => post.categoria === category);
}

export function getFeaturedPosts() {
    return posts.filter(post => post.destaque);
}

export function getPostById(id) {
    return posts.find(post => post.id === parseInt(id));
}
